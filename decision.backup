import { EXPRESSION_TYPE } from "./common";
import { Expression, Condition } from './ExpressionNode';

enum HIT_POLICY {
    Unique = 'U',
    Any = 'A',
    First = 'F',
    RuleOrder = 'R',
    Collect = 'C'
}
// https://docs.camunda.org/manual/7.9/reference/dmn11/decision-table/hit-policy/

class DTExecutor {
    dt: DecisionTable;
    input;
    context;
    rulesPassed: Rule[];
    results;
    constructor(dt, input) {
        this.dt = dt;
        this.input = input;
        this.context = input;
        this.results = [];
        this.rulesPassed = [];
    }
    execute() {
        var r = 0;
        this.executeRules();
        console.log(this.rulesPassed);
        console.log(this.results);

    }
    executeRules() {
        var r = 0;
        const rules = this.dt.rules;
        let ret;
        for (r = 0; r < rules.length; r++)
        {
            let rule = rules[r];
            const output = {};
            ret = rule.evaluate(this.input, output);
            if (ret) {
                console.log(" Rule #" + rule.id + " has returned");
                this.results.push(output);
                return;
            }
            else
                console.log(" Rule #" + rule.id + " has failed");
        }
        console.log("**No Rule has returned**");

    }
    /*
    evaluateOutcome(rule:Rule) {

        this.rulesPassed.push(rule);

        let values = this.input;
        const actions= this.dt.actionVars;
        var c;
        var resultValues = [];
        this.results.push(resultValues);
        for (c = 0; c < actions.length; c++) {
            const varName = actions[c]['name'];
            const expr = rule.actions[c];

            let val = this.evaluateExp(varName, expr);
            resultValues.push(val);
            console.log(">" + varName + " " + expr + ":" + val);
        }
    }
    evaluateRule(rule:Rule) {

        let values = this.input;
        var allTrue = true;
        var c;
        for (c = 0; c < this.dt.conditionVars.length; c++) {
            const varName = this.dt.conditionVars[c]['name'];
            const expr= rule.conditions[c];
            const val = values[c];

            if (!this.evaluateCond(varName,expr , val)) {
                console.log('condition:' + varName +" "+ expr + "vs: " +val + ' not true .. skipping');
                allTrue = false;
                break;
            }
            else 
                console.log('condition:' + varName + " " + expr + "vs: " + val + ' true');

        }
        if (allTrue) {
            return true;
        }
        else
            return false;
    }
    /*
    evaluateCond(name,text, value) {

        value = trimParam(value);

        const expr = Expression.compile(text,true);

        const ret = expr.evaluateCondition(this.context, value);

        console.log('evaluated: '+name+" : "+text+' against:' +value+'result:' + ret);

        return ret;
    }
    evaluateExp(name,text) {

        console.log("evaluating action expression for " + name + " " + text);
        const expr = Expression.compile(text,false);

        const ret = expr.evaluate(this.context);

        expr.display();
        console.log('result:' + ret);

        return ret;
    }
    */
    
}

class Rule {
    id;
    conditions: Condition[];
    actions: Expression[];
    dt: DecisionTable;

    constructor(dt, id, conditions, actions) {
        this.dt = dt;
        this.id = id;
        let i;
        this.conditions = [];
        this.actions = [];
        for (i = 0; i < conditions.length; i++) {
            const cond: String = conditions[i];
            const varName = dt.conditionVars[i].name;
            this.conditions.push(new Condition(cond, varName));
        }
        for (i = 0; i < actions.length; i++) {
            const action: String = actions[i];
            this.actions.push(new Expression(action));
        }
    }
    asJson() {
        return [this.id,this.conditions,this.actions];
    }
    compile() {
        this.conditions.forEach(cond => { cond.compile(); });
        this.actions.forEach(action=> { action.compile(); });

        return null;
    }
    evaluate(data,output) {
        let values = data;
        var allTrue = true;
        var c;

        for (c = 0; c < this.conditions.length; c++) {
            const cond:Condition = this.conditions[c];
            const varName = cond.variableName;
            const val = data[varName];
            const ret = cond.evaluate(data);
            if (!ret) {
                console.log('condition:' + varName + " " + cond.script + "vs: " + val + ' not true .. skipping');
                allTrue = false;
                break;
            }
            else
                console.log('condition:' + varName + " " + cond.script+ "vs: " + val + ' true');

        }
        if (allTrue) {
            for (c = 0; c < this.actions.length; c++) {
                const action: Expression = this.actions[c];
                const outVar = this.dt.actionVars[c];
                const ret = action.evaluate(data);
                output[outVar.name] = ret;
            }
            return true;
        }
        else
            return false;
    }
}
class DTVariable {
    name;
    type: 'String'|'Number'|'Money'|'Date';
}
class DecisionTable {
    name;
    conditionVars: DTVariable[];
    actionVars: DTVariable[];
    rules: Rule[];
    hitPolicy: HIT_POLICY;

    results: any[];

    constructor({ name, conditionVars, actionVars, rules, hitPolicy }) {

        this.name = name;
        const condCount = conditionVars.length;
        const actioCount = actionVars.length
        this.conditionVars = conditionVars;
        this.actionVars = actionVars;
        this.hitPolicy = hitPolicy;

        let id = 1;
        this.rules = [];
        rules.forEach(rule => {
            this.rules.push(new Rule(this, rule[0], rule.slice(1,condCount+1),rule.slice(condCount+1)));
        });
    }
    load(source) {

    }
    compile() {
        const image = {  rules: [] };
        this.rules.forEach(rule => {
            image.rules.push(rule.compile());
        });
        return image;
    }
    evaluate(data) {
        this.results=[];
            var r = 0;
            const rules = this.rules;
            let ret;
            for (r = 0; r < rules.length; r++) {
                let rule = rules[r];
                const output = {};
                ret = rule.evaluate(data, output);
                if (ret) {
                    console.log(" Rule #" + rule.id + " has returned");
                    this.results.push(output);
                    return;
                }
                else
                    console.log(" Rule #" + rule.id + " has failed");
            }
            console.log("**No Rule has returned**");


    }
    saveAsJson() {
        const rules=[];
        this.rules.forEach(rule => { rules.push(rule.asJson()) });
        const obj = {
            name: this.name,
            hitPolicy: this.hitPolicy,
            conditionVars: this.conditionVars,
            actionVars: this.actionVars,
            rules: rules
        };
        return JSON.stringify(obj, null, 2);
    }
    static load(json) {

        return new DecisionTable(json);
    }
}

function trimParam(param) {
    if (param.startsWith('"') && param.endsWith('"'))
        return param.substring(1, param.length - 1);
    if (param.startsWith("'") && param.endsWith("'"))
        return param.substring(1, param.length - 1);
    else
        return param.trim();
}
